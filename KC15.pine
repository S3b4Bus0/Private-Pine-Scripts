// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© benso87
//
// Credit to:
// Eric Crown for the strategy
// The_Caretaker for the indicators referenced for calculations.
//
//@version=5
strategy("KC15", overlay=true, initial_capital=1000, default_qty_value=10, default_qty_type=strategy.percent_of_equity, calc_on_every_tick=true, process_orders_on_close=true, backtest_fill_limits_assumption=1)

//Dates
startDate	= input.time	(timestamp('1 Jan 2022 00:00'), title='Start', group='Dates')
endDate		= input.time	(timestamp('1 Jan 2100 00:00'), title='End', group='Dates')

// Moving Average Inputs
ma1Color 	= input.color	(#0bff00, title="MA 1", inline="MA 1", group="Moving Averages")
ma1Length 	= input.int		(21, title="Length", minval=1, inline="MA 1", group="Moving Averages")
ma1Type 	= input.string	("EMA", title="Type", options=["SMA","EMA"], inline="MA 1", group="Moving Averages")
ma2Color 	= input.color	(#ff0014, title="MA 2", inline="MA 2", group="Moving Averages")
ma2Length 	= input.int		(55, title="Length", minval=1, inline="MA 2", group="Moving Averages")
ma2Type 	= input.string	("EMA", title="Type", options=["SMA","EMA"], inline="MA 2", group="Moving Averages")

//Signal inputs
bbwp_threshold	 	= input.float	(35, 'BBWP threshold', minval=0.1, maxval=100, step=0.01, inline='1', group='Signal Settings')
includeLongs		= input.bool	(true, 'Longs', inline='2', group='Signal Settings')
pmarp_long_signal 	= input.float	(15, 'PMARP long signal', minval=0.1, maxval=100, step=0.01, inline='3', group='Signal Settings')
pmarp_long_exit		= input.float	(75, 'PMARP long exit', minval=0.1, maxval=100, step=0.01, inline='3', group='Signal Settings')
includeShorts		= input.bool	(true, 'Shorts', inline='4', group='Signal Settings')
pmarp_short_signal	= input.float	(85, 'PMARP short signal', minval=0.1, maxval=100, step=0.01, inline='5', group='Signal Settings')
pmarp_short_exit	= input.float	(25, 'PMARP short exit', minval=0.1, maxval=100, step=0.01, inline='5', group='Signal Settings')
errorMarginInput    = input.float   (10, 'Margin for Error (%)', minval=0, inline='6', group='Signal Settings')

//BBWP input variable declarations
var string STM = 'Spectrum'
var string SLD = 'Solid'
var string BGR = 'Blue Green Red'
var string BR  = 'Blue Red'

// BBWP Inputs
i_priceSrc      = input.source  (close, 'Price Source', group='BBWP Properties')
i_basisType     = input.string  ('SMA', 'Basis Type', options=['SMA', 'EMA', 'VWMA'], group='BBWP Properties')
i_bbwpLen       = input.int     (13, 'Length', minval=1, group='BBWP Properties')
i_bbwpLkbk      = input.int     (252, 'Lookback', minval=1, group='BBWP Properties')

// PMARP Inputs
i_src_price         = input.source  (close, 'Price source', inline='1', group='PMARP Properties')
i_pmarp_lookback    = input.int		(350, 'Lookback', minval=1, maxval=1900, inline='2', group='PMARP Properties')
i_ma_len            = input.int     (20, 'PMAR length', minval=1, inline='3', group='PMARP Properties')
i_ma_typ            = input.string  ('VWMA', 'MA type...', options=[ 'SMA', 'EMA', 'HMA', 'RMA', 'VWMA' ], inline='3', group='PMARP Properties')


//////////////////////////////////////////////////////////////
// Credit to The_Caretaker
// BBWP

// BBWP function declarations
f_maType ( _price, _len, _type ) =>
    _type == 'SMA' ? ta.sma ( _price, _len ) : _type == 'EMA' ? ta.ema ( _price, _len ) : ta.vwma ( _price, _len )

f_bbwp ( _price, _bbwLen, _bbwpLen, _type ) =>
    float _basis = f_maType ( _price, _bbwLen, _type )
    float _dev = ta.stdev ( _price, _bbwLen )
    _bbw = ( _basis + _dev - ( _basis - _dev )) / _basis
    _bbwSum = 0.0
    _len = bar_index < _bbwpLen ? bar_index : _bbwpLen
    for _i = 1 to _len by 1
        _bbwSum += ( _bbw[_i] > _bbw ? 0 : 1 )
        _bbwSum
    _return = bar_index >= _bbwLen ? ( _bbwSum / _len) * 100 : na
    _return

// BBWP calculations
bbwp	= f_bbwp ( i_priceSrc, i_bbwpLen, i_bbwpLkbk, i_basisType )


//////////////////////////////////////////////////////////////
// Credit to The_Caretaker
// PMARP

// PMARP function declarations
f_prior_sum ( _P, _X ) =>
    math.sum ( _P[1], _X - 1 )

f_ma_val ( _P, _typ, _len ) =>
    _typ == 'SMA' ? ta.sma ( _P, _len ) : _typ == 'EMA' ? ta.ema ( _P, _len ) : _typ == 'RMA' ? ta.rma ( _P, _len ) : _typ == 'HMA' ? ta.hma ( _P, _len ) : ta.vwma ( _P, _len )

f_pmarp ( _price, _pmarLen, _pmarpLen, _type_p ) =>
    _pmar = math.abs ( _price / f_ma_val ( _price, _type_p, _pmarLen ))
    _pmarpSum = 0
    _len = bar_index < _pmarpLen ? bar_index : _pmarpLen
    for i = 1 to _len by 1
        _pmarpSum += ( _pmar[i] > _pmar ? 0 : 1 )
        _pmarpSum
    _return = bar_index >= _pmarLen ? _pmarpSum / _len * 100 : na

// PMARP calculations
ma          = f_ma_val ( i_src_price, i_ma_typ, i_ma_len )
pmar        = i_src_price / ma
pmarp       = f_pmarp ( i_src_price, i_ma_len, i_pmarp_lookback, i_ma_typ )


//////////////////////////////////////////////////////////////
// Calculations

// Error margin
atr = ta.atr(21)
errorMargin = atr * errorMarginInput / 100

// Moving averages
ma1 = ta.ema(close, ma1Length)
ma2 = ta.ema(close, ma2Length)

ma1Above2 = ma1 > ma2
ma1Below2 = ma1 < ma2
ma12mid = math.avg(ma1, ma2)

silverCross = ta.crossover(ma1, ma2)
darkCross = ta.crossover(ma2, ma1)

ma2ishLong = ma2 + errorMargin
ma2ishShort = ma2 - errorMargin

ma2TestLong = close <= open and ((low <= ma2ishLong and close >= ma2ishShort) or (close[1] < ma2ishLong[1] and close >= ma2) or (close <= ma2ishLong and close >= ma2ishShort)) and close <= ma12mid
ma2TestShort = close >= open and ((high >= ma2ishShort and close <= ma2ishLong) or (close[1] > ma2ishShort[1] and close <= ma2) or (close <= ma2ishShort and close >= ma2ishLong)) and close >= ma12mid

maLongSignal 	= ma1Above2 and close < ma1 and ma2TestLong
maShortSignal 	= ma1Below2 and close > ma1 and ma2TestShort

// BBWP
bbwpLow	= bbwp < bbwp_threshold

// PMARP
pmarpLongSignal		= pmarp <= pmarp_long_signal
pmarpShortSignal	= pmarp >= pmarp_short_signal

// Signals
longSignal 			= includeLongs and maLongSignal and bbwpLow and pmarpLongSignal and time >= startDate and time <= endDate
longExit 			= pmarp >= pmarp_long_exit or darkCross
shortSignal 		= includeShorts and maShortSignal and bbwpLow and pmarpShortSignal and time >= startDate and time <= endDate
shortExit 			= pmarp <= pmarp_short_exit or silverCross


//////////////////////////////////////////////////////////////
// Plots

// Background
bgcolor(ma1Above2 ? color.new(color.green, transp=80) : ma1Below2 ? color.new(color.red, transp=80) : na)

// Moving average plots
plot(ma1, title="MA 1", color=ma1Color, linewidth=2, offset=0)
plot(ma2, title="MA 2", color=ma2Color, linewidth=2, offset=0)


//////////////////////////////////////////////////////////////
// Strategy

strategy.entry("LONG", strategy.long, when=longSignal)
strategy.close("LONG", when=longExit)

strategy.entry("SHORT", strategy.short, when=shortSignal)
strategy.close("SHORT", when=shortExit)
